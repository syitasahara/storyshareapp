const p="ShareYourStoryDB";const y="stories",b="outbox",x="settings",g="drafts";class u{static async init(){return new Promise((t,o)=>{const r=indexedDB.open(p,6);r.onerror=()=>{console.error("IndexedDB open error:",r.error),o(r.error)},r.onsuccess=()=>{console.log("IndexedDB opened successfully");const a=r.result;a.onversionchange=()=>{a.close(),console.log("Database is outdated, please reload the page.")},t(a)},r.onupgradeneeded=a=>{const n=a.target.result;if(console.log("Database upgrade needed from version",a.oldVersion,"to",6),n.objectStoreNames.contains(y)){const c=a.currentTarget.transaction.objectStore(y);c.indexNames.contains("offlineId")||c.createIndex("offlineId","offlineId",{unique:!0})}else{console.log("Creating stories store");const e=n.createObjectStore(y,{keyPath:"id"});e.createIndex("createdAt","createdAt",{unique:!1}),e.createIndex("name","name",{unique:!1}),e.createIndex("description","description",{unique:!1}),e.createIndex("isSynced","isSynced",{unique:!1}),e.createIndex("hasLocation","hasLocation",{unique:!1}),e.createIndex("lastUpdated","lastUpdated",{unique:!1}),e.createIndex("offlineId","offlineId",{unique:!0})}if(!n.objectStoreNames.contains(b)){console.log("Creating outbox store");const e=n.createObjectStore(b,{keyPath:"id",autoIncrement:!0});e.createIndex("createdAt","createdAt",{unique:!1}),e.createIndex("status","status",{unique:!1}),e.createIndex("retryCount","retryCount",{unique:!1}),e.createIndex("type","type",{unique:!1})}if(n.objectStoreNames.contains(x)||(console.log("Creating settings store"),n.createObjectStore(x,{keyPath:"key"})),!n.objectStoreNames.contains(g)){console.log("Creating drafts store");const e=n.createObjectStore(g,{keyPath:"id",autoIncrement:!0});e.createIndex("createdAt","createdAt",{unique:!1}),e.createIndex("updatedAt","updatedAt",{unique:!1}),e.createIndex("title","title",{unique:!1})}},r.onblocked=()=>{console.warn("Database upgrade blocked. Please close other tabs using this app."),o(new Error("Database upgrade blocked"))}})}static async addStory(t){try{const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([y],"readwrite").objectStore(y),c={...t,lastUpdated:new Date().toISOString(),isSynced:t.isSynced||!1,hasLocation:!!(t.lat&&t.lon),offlineId:t.offlineId||`offline_${Date.now()}_${Math.random().toString(36).substr(2,9)}`},s=e.put(c);s.onsuccess=()=>{console.log("Story added to IndexedDB:",c.id||c.offlineId),r(s.result)},s.onerror=d=>{console.error("Add story error:",d),a(new Error("Failed to add story to database"))}})}catch(o){throw console.error("Database operation failed:",o),o}}static async getStory(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([y],"readonly").objectStore(y).get(t);e.onsuccess=()=>r(e.result),e.onerror=c=>{console.error("Get story error:",c),a(new Error("Failed to retrieve story"))}})}static async getAllStories(){const t=await this.init();return new Promise((o,r)=>{const n=t.transaction([y],"readonly").objectStore(y).getAll();n.onsuccess=()=>o(n.result),n.onerror=e=>{console.error("Get all stories error:",e),r(new Error("Failed to retrieve stories"))}})}static async deleteStory(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([y],"readwrite").objectStore(y).delete(t);e.onsuccess=()=>{console.log("Story deleted from IndexedDB:",t),r(!0)},e.onerror=c=>{console.error("Delete story error:",c),a(new Error("Failed to delete story"))}})}static async searchStories(t){const o=await this.init();return new Promise((r,a)=>{const c=o.transaction([y],"readonly").objectStore(y).getAll();c.onsuccess=()=>{const s=c.result,d=t.toLowerCase(),l=s.filter(w=>{var S,f;return((S=w.name)==null?void 0:S.toLowerCase().includes(d))||((f=w.description)==null?void 0:f.toLowerCase().includes(d))});r(l)},c.onerror=s=>{console.error("Search stories error:",s),a(new Error("Failed to search stories"))}})}static async filterStories(t={}){const o=await this.init();return new Promise((r,a)=>{const c=o.transaction([y],"readonly").objectStore(y).getAll();c.onsuccess=()=>{let s=c.result;if(t.isSynced!==void 0&&(s=s.filter(d=>d.isSynced===t.isSynced)),t.hasLocation!==void 0&&(s=s.filter(d=>d.hasLocation===t.hasLocation)),t.offlineOnly&&(s=s.filter(d=>d.offlineId)),t.dateRange){const{start:d,end:l}=t.dateRange;s=s.filter(w=>{const S=new Date(w.createdAt);return(!d||S>=new Date(d))&&(!l||S<=new Date(l))})}r(s)},c.onerror=s=>{console.error("Filter stories error:",s),a(new Error("Failed to filter stories"))}})}static async sortStories(t="createdAt",o="desc"){const r=await this.init();return new Promise((a,n)=>{const s=r.transaction([y],"readonly").objectStore(y).getAll();s.onsuccess=()=>{let d=s.result;d.sort((l,w)=>{let S=l[t],f=w[t];return t.includes("At")&&(S=new Date(S).getTime(),f=new Date(f).getTime()),typeof S=="string"&&(S=S.toLowerCase(),f=f.toLowerCase()),o==="asc"?S>f?1:-1:S<f?1:-1}),a(d)},s.onerror=d=>{console.error("Sort stories error:",d),n(new Error("Failed to sort stories"))}})}static async getUnsyncedStories(){return this.filterStories({isSynced:!1})}static async markStoryAsSynced(t,o){const r=await this.init();return new Promise((a,n)=>{const c=r.transaction([y],"readwrite").objectStore(y),d=c.index("offlineId").get(t);d.onsuccess=()=>{const l=d.result;if(l){l.isSynced=!0,l.serverId=o,l.lastUpdated=new Date().toISOString();const w=c.put(l);w.onsuccess=()=>{console.log("Story marked as synced:",t,"->",o),a(l)},w.onerror=S=>{console.error("Update story error:",S),n(new Error("Failed to update story"))}}else n(new Error("Story not found with offlineId: "+t))},d.onerror=l=>{console.error("Get story for sync error:",l),n(new Error("Failed to retrieve story for sync"))}})}static async syncWithAPI(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([y],"readwrite").objectStore(y),c=e.getAll();c.onsuccess=async()=>{const s=c.result;new Set(s.map(l=>l.id));const d=new Set(t.map(l=>l.id));try{let l=0,w=0;for(const f of t){const h=s.find(m=>m.id===f.id);if(h){const m={...h,...f,isSynced:!0,lastUpdated:new Date().toISOString()};await e.put(m),w++}else{const m={...f,isSynced:!0,lastUpdated:new Date().toISOString(),hasLocation:!!(f.lat&&f.lon)};await e.put(m),l++}}let S=0;for(const f of s)!d.has(f.id)&&f.isSynced&&(await e.delete(f.id),S++);r({added:l,updated:w,removed:S})}catch(l){a(l)}},c.onerror=s=>{console.error("Sync with API error:",s),a(new Error("Failed to sync with API"))}})}static async createOfflineStory(t){try{const o={...t,id:`offline_${Date.now()}`,offlineId:`offline_${Date.now()}_${Math.random().toString(36).substr(2,9)}`,createdAt:new Date().toISOString(),isSynced:!1,hasLocation:!!(t.lat&&t.lon),lastUpdated:new Date().toISOString()};return await this.addStory(o),await this.addToOutbox({type:"story",data:o,createdAt:new Date().toISOString(),status:"pending",retryCount:0}),console.log("Offline story created:",o.offlineId),o}catch(o){throw console.error("Failed to create offline story:",o),o}}static async addToOutbox(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([b],"readwrite").objectStore(b),c={...t,createdAt:t.createdAt||new Date().toISOString(),status:t.status||"pending",retryCount:t.retryCount||0,lastRetry:t.lastRetry||null},s=e.add(c);s.onsuccess=()=>{console.log("Added to outbox:",s.result),r(s.result)},s.onerror=d=>{console.error("Add to outbox error:",d),a(new Error("Failed to add to outbox"))}})}static async getOutboxItems(t=null){const o=await this.init();return new Promise((r,a)=>{const c=o.transaction([b],"readonly").objectStore(b).getAll();c.onsuccess=()=>{let s=c.result;t&&(s=s.filter(d=>d.status===t)),s.sort((d,l)=>new Date(d.createdAt)-new Date(l.createdAt)),r(s)},c.onerror=s=>{console.error("Get outbox items error:",s),a(new Error("Failed to get outbox items"))}})}static async updateOutboxItem(t,o){const r=await this.init();return new Promise((a,n)=>{const c=r.transaction([b],"readwrite").objectStore(b),s=c.get(t);s.onsuccess=()=>{const d=s.result;if(!d){n(new Error("Outbox item not found"));return}const l={...d,...o,lastUpdated:new Date().toISOString()},w=c.put(l);w.onsuccess=()=>a(l),w.onerror=S=>{console.error("Update outbox item error:",S),n(new Error("Failed to update outbox item"))}},s.onerror=d=>{console.error("Get outbox item for update error:",d),n(new Error("Failed to retrieve outbox item"))}})}static async removeFromOutbox(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([b],"readwrite").objectStore(b).delete(t);e.onsuccess=()=>{console.log("Removed from outbox:",t),r(!0)},e.onerror=c=>{console.error("Remove from outbox error:",c),a(new Error("Failed to remove from outbox"))}})}static async saveDraft(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([g],"readwrite").objectStore(g),c={...t,createdAt:t.createdAt||new Date().toISOString(),updatedAt:new Date().toISOString()},s=e.put(c);s.onsuccess=()=>r(s.result),s.onerror=d=>{console.error("Save draft error:",d),a(new Error("Failed to save draft"))}})}static async getDrafts(){const t=await this.init();return new Promise((o,r)=>{const n=t.transaction([g],"readonly").objectStore(g).getAll();n.onsuccess=()=>{const e=n.result;e.sort((c,s)=>new Date(s.updatedAt)-new Date(c.updatedAt)),o(e)},n.onerror=e=>{console.error("Get drafts error:",e),r(new Error("Failed to get drafts"))}})}static async deleteDraft(t){const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([g],"readwrite").objectStore(g).delete(t);e.onsuccess=()=>r(!0),e.onerror=c=>{console.error("Delete draft error:",c),a(new Error("Failed to delete draft"))}})}static async saveSetting(t,o){const r=await this.init();return new Promise((a,n)=>{const c=r.transaction([x],"readwrite").objectStore(x).put({key:t,value:o});c.onsuccess=()=>a(!0),c.onerror=s=>{console.error("Save setting error:",s),n(new Error("Failed to save setting"))}})}static async getSetting(t,o=null){const r=await this.init();return new Promise((a,n)=>{const c=r.transaction([x],"readonly").objectStore(x).get(t);c.onsuccess=()=>{var s;return a(((s=c.result)==null?void 0:s.value)||o)},c.onerror=s=>{console.error("Get setting error:",s),n(new Error("Failed to get setting"))}})}static async getDatabaseSize(){const t=await this.init();return new Promise(o=>{const r=t.transaction([y,b,x,g],"readonly"),a=[r.objectStore(y),r.objectStore(b),r.objectStore(x),r.objectStore(g)];let n=0,e=0;a.forEach(c=>{const s=c.count();s.onsuccess=()=>{n+=s.result,e++,e===a.length&&o({totalItems:n,stories:a[0].count,outbox:a[1].count,settings:a[2].count,drafts:a[3].count})},s.onerror=()=>{e++,e===a.length&&o({totalItems:n,error:!0})}})})}static async clearDatabase(){return new Promise((t,o)=>{const r=indexedDB.deleteDatabase(p);r.onsuccess=()=>{console.log("Database cleared successfully"),t()},r.onerror=()=>{console.error("Error clearing database:",r.error),o(r.error)},r.onblocked=()=>{console.warn("Database deletion blocked"),o(new Error("Database deletion blocked by other tabs"))}})}static async exportData(){const t=await this.getAllStories(),o=await this.getOutboxItems(),r=await this.getDrafts();return{exportDate:new Date().toISOString(),stories:t,outbox:o,drafts:r,totalItems:t.length+o.length+r.length}}static async importData(t){if(!t.stories)return;const o=await this.init();return new Promise((r,a)=>{const e=o.transaction([y],"readwrite").objectStore(y);e.clear();let c=0;const s=t.stories.length;if(s===0){r({imported:0});return}for(const d of t.stories){const l=e.add(d);l.onsuccess=()=>{c++,c===s&&r({imported:c})},l.onerror=()=>a(new Error("Failed to import story"))}})}static async processOfflineSync(){try{const t=await this.getUnsyncedStories(),o=await this.getOutboxItems("pending");console.log(`Starting sync: ${t.length} unsynced stories, ${o.length} pending outbox items`);let r=0,a=0;for(const n of t)try{await this.simulateApiCall(n),await this.markStoryAsSynced(n.offlineId,`server_${Date.now()}`),r++}catch(e){console.error("Failed to sync story:",n.offlineId,e),a++}for(const n of o)try{n.type==="story"&&(await this.simulateApiCall(n.data),await this.updateOutboxItem(n.id,{status:"completed"}),r++)}catch(e){console.error("Failed to process outbox item:",n.id,e),await this.updateOutboxItem(n.id,{retryCount:n.retryCount+1,lastRetry:new Date().toISOString(),status:n.retryCount>=3?"failed":"pending"}),a++}return{success:!0,synced:r,failed:a,total:r+a}}catch(t){return console.error("Sync process failed:",t),{success:!1,error:t.message,synced:0,failed:0,total:0}}}static async simulateApiCall(t){return new Promise((o,r)=>{setTimeout(()=>{Math.random()>.2?o({success:!0,id:`server_${Date.now()}`}):r(new Error("Simulated API failure"))},1e3)})}}const I={async init(){try{return await u.init()}catch(i){throw console.error("Failed to initialize database:",i),i}},async addStory(i){return u.addStory(i)},async getStory(i){return u.getStory(i)},async getAllStories(){return u.getAllStories()},async deleteStory(i){return u.deleteStory(i)},async searchStories(i){return u.searchStories(i)},async filterStories(i){return u.filterStories(i)},async sortStories(i,t){return u.sortStories(i,t)},async getUnsyncedStories(){return u.getUnsyncedStories()},async markStoryAsSynced(i,t){return u.markStoryAsSynced(i,t)},async syncWithAPI(i){return u.syncWithAPI(i)},async createOfflineStory(i){return u.createOfflineStory(i)},async processOfflineSync(){return u.processOfflineSync()},async addToOutbox(i){return u.addToOutbox(i)},async getOutboxItems(i){return u.getOutboxItems(i)},async updateOutboxItem(i,t){return u.updateOutboxItem(i,t)},async removeFromOutbox(i){return u.removeFromOutbox(i)},async saveDraft(i){return u.saveDraft(i)},async getDrafts(){return u.getDrafts()},async deleteDraft(i){return u.deleteDraft(i)},async saveSetting(i,t){return u.saveSetting(i,t)},async getSetting(i,t){return u.getSetting(i,t)},async getDatabaseSize(){return u.getDatabaseSize()},async clearDatabase(){return u.clearDatabase()},async exportData(){return u.exportData()},async importData(i){return u.importData(i)}};export{I as s};
